Задание 17. Метод ближайшего соседа с улучшением (TSP)
Условие. Построить маршрут TSP методом ближайшего соседа, затем улучшить его 2‑opt.
Алгоритм: комбинация «ближайший сосед» + 2‑opt.
Язык примера: Python
def tsp_hybrid(dist):
 n = len(dist)
 # Шаг 1: ближайший сосед
 path = [0]
 visited = [False] * n
 visited[0] = True
 for _ in range(n - 1):
 curr = path[-1]
 next_city = -1
 # ДОПИСАТЬ: найти ближайший непосещённый город
 path.append(next_city)
 visited[next_city] = True
 # Шаг 2: 2-opt улучшение
 path = twoOpt(path, dist) # использовать функцию из Задания 3
 return path
Что дописать: поиск next_city по минимуму dist[curr][j] среди непосещённых.


1 Создание матрицы расстояний между всеми городами
dist_matrix = create_distance_matrix(cities)


2Построение начального маршрута методом ближайшего соседа

for j in range(n):
    if not visited[j] and dist[curr][j] < min_dist:

3 Улучшение маршрута с помощью алгоритма 2-opt


path = twoOpt(path, dist)


4 Проверка всех возможных пар рёбер для оптимизации в 2-opt

for i in range(1, n - 2):
    for j in range(i + 1, n):


5 Вычисление общей длины финального маршрута

total += dist[path[i]][path[(i + 1) % n]]






import math

def twoOpt(path, dist):
    """Функция улучшения маршрута методом 2-opt"""
    n = len(path)
    improved = True
    while improved:
        improved = False
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if j - i == 1:
                    continue
                # Текущая длина ребер (i-1, i) и (j, j+1)
                current = dist[path[i-1]][path[i]] + dist[path[j]][path[(j+1)%n]]
                # Новая длина ребер (i-1, j) и (i, j+1)
                new = dist[path[i-1]][path[j]] + dist[path[i]][path[(j+1)%n]]
                if new < current:
                    # Переворачиваем сегмент между i и j
                    path[i:j+1] = reversed(path[i:j+1])
                    improved = True
    return path

def calculate_distance(city1, city2):
    """Вычисление евклидова расстояния между двумя городами"""
    return math.sqrt((city1[0] - city2[0])**2 + (city1[1] - city2[1])**2)

def create_distance_matrix(cities):
    """Создание матрицы расстояний между всеми городами"""
    n = len(cities)
    dist = [[0.0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                dist[i][j] = calculate_distance(cities[i], cities[j])
    return dist

def tsp_hybrid(dist):
    n = len(dist)
    # Шаг 1: ближайший сосед
    path = [0]
    visited = [False] * n
    visited[0] = True
    for _ in range(n - 1):
        curr = path[-1]
        next_city = -1
        min_dist = float('inf')
        for j in range(n):
            if not visited[j] and dist[curr][j] < min_dist:
                min_dist = dist[curr][j]
                next_city = j
        path.append(next_city)
        visited[next_city] = True
    # Шаг 2: 2-opt улучшение
    path = twoOpt(path, dist)
    return path

def calculate_total_distance(path, dist):
    """Вычисление общей длины маршрута"""
    total = 0
    n = len(path)
    for i in range(n):
        total += dist[path[i]][path[(i + 1) % n]]
    return total

def main():
    print("=== TSP: Метод ближайшего соседа с улучшением 2-opt ===")
    
    # Ввод количества городов
    while True:
        try:
            n = int(input("Введите количество городов: "))
            if n > 1:
                break
            else:
                print("Количество городов должно быть больше 1")
        except ValueError:
            print("Пожалуйста, введите целое число")
    
    # Ввод координат городов
    cities = []
    print("\nВведите координаты городов (x y):")
    for i in range(n):
        while True:
            try:
                coords = input(f"Город {i}: ").split()
                if len(coords) == 2:
                    x = float(coords[0])
                    y = float(coords[1])
                    cities.append((x, y))
                    break
                else:
                    print("Пожалуйста, введите две координаты через пробел")
            except ValueError:
                print("Пожалуйста, введите числа")
    
    # Создание матрицы расстояний
    dist_matrix = create_distance_matrix(cities)
    
    print("\nМатрица расстояний:")
    for i in range(n):
        for j in range(n):
            print(f"{dist_matrix[i][j]:8.2f}", end=" ")
        print()
    
    # Построение маршрута
    print("\nПостроение маршрута...")
    path = tsp_hybrid(dist_matrix)
    
    # Вывод результатов
    print(f"\nОптимальный маршрут: {path}")
    print(f"Общая длина маршрута: {calculate_total_distance(path, dist_matrix):.2f}")
    
    # Вывод маршрута по порядку
    print("\nПорядок посещения городов:")
    for i, city_idx in enumerate(path):
        print(f"{i+1}. Город {city_idx} ({cities[city_idx][0]}, {cities[city_idx][1]})")
    print(f"Возврат в город {path[0]}")

if __name__ == "__main__":
    main()







=== TSP: Метод ближайшего соседа с улучшением 2-opt ===
Введите количество городов: 4

Введите координаты городов (x y):
Город 0: 0 0
Город 1: 1 1
Город 2: 4 4
Город 3: 5 5

Матрица расстояний:
    0.00     1.41     5.66     7.07 
    1.41     0.00     4.24     5.66 
    5.66     4.24     0.00     1.41 
    7.07     5.66     1.41     0.00 

Построение маршрута...

Оптимальный маршрут: [0, 1, 2, 3]
Общая длина маршрута: 14.14

Порядок посещения городов:
1. Город 0 (0.0, 0.0)
2. Город 1 (1.0, 1.0)
3. Город 2 (4.0, 4.0)
4. Город 3 (5.0, 5.0)
Возврат в город 0















Общая временная сложность алгоритма: O(n³)


Объяснение:
Временная сложность данного алгоритма определяется тремя основными компонентами. Первый компонент - метод ближайшего соседа - имеет сложность O(n²), поскольку для каждого из n городов выполняется поиск ближайшего непосещённого города среди оставшихся вариантов, что в худшем случае требует n операций на каждом шаге. Второй и наиболее затратный компонент - алгоритм 2-opt - обладает сложностью O(n³) в худшем случае, так как он использует тройной вложенный цикл: внешний while-цикл может выполняться до n раз, а внутри него находятся два вложенных for-цикла, каждый из которых может выполняться до n раз. Третий компонент - создание матрицы расстояний - также имеет сложность O(n²), поскольку требует попарного вычисления расстояний между всеми n городами.

Таким образом, доминирующей операцией является алгоритм 2-opt с его кубической сложностью, что делает общую временную сложность алгоритма O(n³). Это означает, что при увеличении количества городов в 10 раз, время выполнения алгоритма возрастёт примерно в 1000 раз, что ограничивает практическое применение данного метода для очень больших наборов данных, но делает его вполне приемлемым для задач умеренного размера с несколькими десятками или сотнями городов.



17. Генетические алгоритмы
Объясните основные операции генетического алгоритма: отбор, кроссовер и мутация.


Генетический алгоритм включает три основные операции: отбор - выбор наиболее приспособленных особей для размножения на основе их fitness-функции; кроссовер - рекомбинация генов родителей для создания потомков, объединяющая характеристики обоих родителей; мутация - случайное изменение генов у потомков для внесения нового генетического материала и поддержания разнообразия популяции, что предотвращает преждевременную сходимость к локальным оптимумам.
